//
//  main.swift
//  day24
//
//  Created by Mark Johnson on 1/8/19.
//  Copyright Â© 2019 matzsoft. All rights reserved.
//

import Foundation

let test1 = """
###########
#0.1.....2#
#.#######.#
#4.......3#
###########
"""
let input = """
#################################################################################################################################################################################
#...................#.#.#.........#.........#...............#.....#.....#.........#.............#.............#...#.......#.......#...#...#.......#...#...#.#...#.........#...#.#
#.#.#.#.#.#.#.#.#.#.#.#.#.###.###.#.###.#.#.#.#.#.#.#.#.###.#.#.#.#.#.#.#.#.#######.#####.###.#.###.#.#.#.#.#.#.#.#.###.#.#.#########.#.###.###.#.#.#####.#.#.#####.###.#.#.#.#.#
#...#.....#.#...#...#...#.#...#...#.....#...#.#.....#...#.......#.#.....#...........#.........#.#.....#.#...#.........#.#.....#.........#...#.....#.....#.....#...#.#.....#.....#
#.#.#.###.#.#.#.#.#.#.#.#.#.#.#.###.#####.#.###.###.#.###.###.#.#.#.#####.#####.#.#.#.#.###.#.#.#.#.#.#.#######.#.#.#####.#.#####.###.###.#.#.###.#.#.#.###.###.#.#.#.###.#.#.#.#
#.#.#...#...#...........#.......#...#.#.#.#.....#.#.......#...#...#.#.....#...#...#.#.#...........#.#...#...#...#.....#...........#...#0....#...#.#.#.....#.......#.....#...#...#
#.#.#.#.#.#.#.###########.###.###.###.#.#.#.#.#.#.#########.#####.#.#.###.#.#.#.#.#####.#.#.#.###.#.#.###.###.###.#.#.#.###.#.#.#.#.#######.#.#.#.#.#.###.#######.#######.#####.#
#.....#...#...#.#3........#.......#.#...#.#.#...#.......#.#.......#.#...#...#.#.....#...#.....#...#.#.....#.#.......#.......#...............#...#.......#.......#.#.............#
#.#.#.###.###.#.###.#.###.#.#.#.###.#.###.#.#.#######.#.#.###.#.###.#.#.#.#########.#.#.#####.#.#.#.#.#.#.#.#.#.#####.#####.#.###.###.###.###.#.#.###.#.#.###.###.###.#.###.#.###
#...#.....#.......#.#.#...#.............#...........#...........#.....#.#.......#.....#.......#.......#.#.....#.....#.....#.....#.#...#.......#.......#.#.....#.#...#.....#...#.#
#####.###.###.#.###.###.#.#.#####.#.###.#####.#.#.#.#########.#.#.###.#.#.#.#.#.#.###.###.#.#.###.###.#.#####.#.###.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#####.#.#####.#####.###.#.#.#.#
#.....#.........#.......#.#.......#.#.....#...#...#.............#.....#.......#.#...#...#...#...#.....#...#.....#.....#...#.....#...#.#...#...#...#.....#.....#.......#.#...#...#
#.#.#.#.###.#.#.#.#.#.#.#.#.#####.###.###.#####.#.#.#####.#.###.#.#.#.###.#.#.###.#.###.#.#.#.###.###.#.#.#.#########.###.#.#.#.#.#.#.#.#####.#.###.#.#.#.#.###.#.#.#.#.#.#####.#
#.....#.#.....#.....#.....#.#...............#.#.........#.....#.#.....#.....#...#.....#.#.#.#.#...#...#...............#...#.#...#...#.#.#...#.#.#.....#.....#...#...#.#...#...#.#
#.###.#.#.#.#.#.#.#.#.#####.#.#.###.#.#.###.#.#######.#.#.#.#.#.#.#########.###.#.###.###.#.#.#.#########.#.#.###.#.#.#.###.###.###.###.#.###.#.#.#.#.#.###.#.#.###.#.#.#.#.#.#.#
#.#.#.#.#.#...#...#...#.........#...........#...#...#...#.....#...#.#.#.......#.#.....#...........#.........#.......#...#.#.#...#.........#1#.#...#.#.............#...#.........#
###.#.#.###.#.#.#.#.#.#####.#########.###.#.#.#####.###.###.#.#.#.#.#.#.#.###.#.#.#.#.#.#####.#.#.#####.#######.###.#.#.#.#.#.#.#.###.#.#.#.#.###.#.#.#.#.#.###.#.#####.###.#####
#...#.#.....#.....#.........#...#...#...#...#...#.......#.......#.....#.........#.#...#.....#.#...#.....#...#...#.#.#.......#.....#.....#.#...#.#.............#.#...........#.#.#
#.#.#.#.#.###.###.#.#.###.###.###.#.#.#.#####.#.###.###.#.###.#######.###.#.###.#.#.#.#.#.#.#####.###.#.#.#.#.#.#.###########.#.#.#.#.#.#.#.#.#.#.###.###.#.###.#.#.#.###.#.#.#.#
#.........#...#.....#.#...#...#...............#.....#.......#...#.....#...#.#...#.#...#.#.........#...#.#.#.....#.....#.......#.......#.....#.#...........#.....#.#...........#.#
#####.#.#.#.#.#.###.#.#.#.#.#.#.#####.###.#.#.#.###.#.###.#.#.#.#.#.#.###.#.#.###.#.#.#.#.###.#.#.#.#####.#.#####.###.#.#.#.###.#.#.###.###.###.#####.#.#.#.#.#.#.#.###.#####.#.#
#2..........#...#...#.#...#.#.............#.#.#.......#...#.....#...........#.#...#.#.#.....#.#...#.#.#.........#...#...#.#...#.....#.........#...#...#...#.....#.....#.....#...#
#####.#.#.###.#.#####.###.#.#.#.###.###.###.###.#.###.#.#.#####.#.#.#########.#.###.#.#####.#.#####.#.#.###.#.#.#.#.###.###.#.###.#######.#############.###.###.###.###.###.#.###
#.#.......#...#...#...#.......#...........#...#.#.....#...#.......#.....#...#.....#.#.......#.........#...#.#.....#.#...#.............#.....#.............#.#...#.#...#.......#.#
#.#.#.#####.#.#.###.###.###.#.#.#.#.#.#####.#.#.#.#.###.###.#.#####.#.#####.#.#.###.#.#####.#.###.###.###.#.###.#.#.#.#.#.#########.###.###.#######.###.#.#.#.###.#####.###.#.#.#
#.....#.#...#.#.....#...#.....#...#...#...#.#...#...#.#.......#.#...#.......#.#.#.............#...#...#...#.....#.#.........#...#.#.#...#...#...........#...#.#7#.#.....#.....#.#
###.#.#.#.#.#.#.#.#.#.#.#.###.#.#.###.#.#.#.###.#.#.#.#.#.#####.#.#######.#.###.#.#.#.#.#.#####.###.#.#.#.#.#.#.#.#.#.#.#.###.###.#.#.#.#.###.#.#.###.#.#.#.###.#.###.#.#.###.#.#
#.#...#.....#.#...#.#.......#.#.......#.........#.#.#.#...............#.....#...#.#.........#.......#.#.#.#...#...#.#.#.....#.....#.#.#...#...#...#.#.#.....#...#.....#...#...#.#
#.#####.#######.#.#########.#.#.###.###.#.#####.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.###.#.#####.###.#.#.#.#.#.###.#######.#.#.###.#.#.#.###.###.#.###.###.#.#.###.#.###.#.#.#.#####.#.#
#.#.........#.#.#...#.....#.....#...#.............#...#...#.#.......#...#.#.......#.......#...#.....#...#...#.............#.#.........#...#...#...........#...#.......#.#.....#.#
#.#.#.#######.#.#.#.###.#.#.#.#.###.#.#.#.#.#.#.#.#.#####.#.#.###.#.#.#.#.#.#.#.#.###.###.###.#####.#.#.#####.#.#######.#.#.#.#.###.#.#.#.#.###.#.#.#.#.#.#####.#.#.#.#######.#.#
#...#.#.......#.#...#...........#...#.......#.....#...#.....#.........#.....#...#.........#.#...#...#...#.....#.......#...#.............#.#.........#.....#.....#.....#.#...#.#.#
#.###.#.###.#.###.#.###########.#######.###.#########.#.#.#.#.#.###.###.#.#.#.###.#.###.###.#.#.#.#.#.#.#.###.#.#####.#####.#.###.###.#.#.#.#######.###.#.#.#####.###.#.#.###.#.#
#.#.....#.....#.#.....#4........#...#...#.#.....#...#.#.#...#.#.........#.....#.......#.#.......#.#.....#.....#...............#.....#.#.#.#...#.........#...#...#.........#...#.#
###.#####.#.#.#.#########.#.#.#####.#.#.#.###.###.#.#.#.#.#.###.#.#.###.###.#.###.###.#.###########.###.#.#.#.#.###.#####.#.#.#.#.###.###.#.#.#.#.#.#.#.#.###.###.#.###.#.#.#.#.#
#.........#.#.....#.....#.#.....#.#.#.#...#.....#.......#...#.#...#.....#.......#.....#.........#.......#...#.#.#.......#.......#...#...#...#...#.#.#...#.....#...#...#...#.....#
#.#.###.###.###.###.#.###.#.#.###.###.###.#.#.#.#.#####.###.#.#.#.#.#.###.#.#####.#.###.#.#.#.#.#.#.###.#.###.#.#.#.#.#########.#.#####.#.#.#.#.#####.#.#.#######.#.#.###.###.#.#
#.............#.#...#.#.....#.#...#.........#.....#...#.......#...#.......#.......#...........#...#...#.#...#...#.....#...........#.....#.#...#.....#.....#.#.........#.....#.#.#
#.#.#.###.#.#.#####.###.#.#.#.#.#.#.#.#####.###.#.#.#####.#.#.#.#.#####.#.###.#####.#############.#.#.###.#.#.#.#####.#.#.#.#.#.#.#.###.###.###.#.#.#.###.#.#.#.#.#.#.###.#.###.#
#.#...#.#.#.....#.............#...#.........#...#.#...#...#...#...#...........#.#.#.#.....#...#.....#.#.#...#...#.#.........#.....#.........#...........#.....#...#...#.......#.#
#.#.#.#.#.###.#.#.###.#.#######.#.#.#.#.#.#.#.#.#.###.#.###.###.###.#####.#.###.#.#.###.#.#.#######.#.#.#.###.###.#.###.#####.#.#.#####.#.#.#.#.#####.#.#.#####.#.#####.#########
#.......#.....#...#...#.....#...........#...#.#...#.........#...#.....#...........#.....#.#.....#...#...#.#...#...#...#.....#...........#...#.#...#...#.....#.....#...........#6#
#.#.#.#.#######.###.#.#.###.#.#.###.#####.#.###.#.#######.#.#####.#.#.#.#########.#.###.#.#.#####.#.#.###.#.#########.###.#.#####.###.#.###.#.#.#.###.#.###.#.#.#.#.#.#.#.#####.#
#.....#.............#...#.#...#...#.#5......#...#...#.....#.............#.#.......#.....#.....#...........#.........#...#.#.....#.#.#.#...#...........#.#.#.......#.............#
#################################################################################################################################################################################
"""

enum Direction: String, CaseIterable {
    case up = "U", down = "D", left = "L", right = "R"
}

struct Point: Hashable {
    let x: Int
    let y: Int
    
    func distance( other: Point ) -> Int {
        return abs( x - other.x ) + abs( y - other.y )
    }
    
    static func +( left: Point, right: Point ) -> Point {
        return Point(x: left.x + right.x, y: left.y + right.y)
    }
    
    static func ==( left: Point, right: Point ) -> Bool {
        return left.x == right.x && left.y == right.y
    }
    
    func move( direction: Direction ) -> Point {
        switch direction {
        case .up:
            return self + Point(x: 0, y: -1)
        case .right:
            return self + Point(x: 1, y: 0)
        case .down:
            return self + Point(x: 0, y: 1)
        case .left:
            return self + Point(x: -1, y: 0)
        }
    }
}

enum LocationType: String, CaseIterable {
    case open = ".", wall = "#"
}

class Location: Hashable {
    let type: LocationType
    let point: Point
    var distance = Int.max
    
    init( type: LocationType, point: Point ) {
        self.type = type
        self.point = point
    }

    static func == (lhs: Location, rhs: Location) -> Bool {
        return lhs.type == rhs.type && lhs.point == rhs.point
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine( type )
        hasher.combine( point )
    }
}

class Ducts {
    var layout: [[Location]]
    let destinations: [Location]
    var distanceMap = [[Int]]()
    
    init( input: String ) {
        let lines = input.split(separator: "\n")
        var destinations: [ Int : Location ] = [:]
        
        layout = []
        for ( y, line ) in lines.enumerated() {
            var row: [Location] = []
            
            for ( x, char ) in line.enumerated() {
                let point = Point( x: x, y: y )
                
                switch char {
                case ".":
                    row.append( Location( type: .open, point: point ) )
                case "#":
                    row.append( Location( type: .wall, point: point ) )
                case "0"..."9":
                    let location = Location( type: .open, point: point )
                    
                    row.append( location )
                    destinations[ Int( String( char ) )! ] = location
                default:
                    print( "Invalid charcter '\(char) in input" )
                    exit(1)
                }
            }
            layout.append( row )
        }
        
        self.destinations = destinations.sorted { $0.key < $1.key }.map { $0.value }
        distanceMap = findDistances()
    }
    
    subscript( point: Point ) -> Location? {
        guard point.x >= 0 && point.y >= 0 else { return nil }
        guard point.x < layout[0].count && point.y < layout.count else { return nil }
        
        return layout[point.y][point.x]
    }
    
    func printLayout() -> Void {
        for row in layout {
            var line = ""
            
            for location in row {
                if let index = destinations.firstIndex( of: location ) {
                    line += String( index )
                } else {
                    line += location.type.rawValue
                }
            }
            
            print(line)
        }
        
        print()
    }
    
    func reset() -> Void {
        layout.forEach { $0.forEach { $0.distance = Int.max } }
    }
    
    func possibleMoves( position: Location ) -> [Location] {
        var results: [Location] = []
        
        for direction in Direction.allCases {
            let nextPoint = position.point.move(direction: direction)
            
            if let nextLocation = self[nextPoint] {
                if nextLocation.type == .open {
                    results.append( nextLocation )
                }
            }
        }
        
        return results
    }
    
    func findRoute( begin: Location, end: Location ) -> Int {
        var queue = [ begin ]
        
        reset()
        begin.distance = 0
        while let next = queue.first {
            queue.removeFirst()
            
            if next == end { return next.distance }
            
            for move in possibleMoves( position: next ) {
                if move.distance == Int.max {
                    move.distance = next.distance + 1
                    queue.append( move )
                }
            }
        }
        
        return Int.max
    }
    
    func pathDistance( current: Int, remaining: Set<Int> ) -> ( Int, Int ) {
        let remaining = remaining.subtracting( [ current ] )
        guard remaining.count > 1 else {
            let last = remaining.first!
            return ( distanceMap[current][last], last )
        }
        
        var distance = Int.max
        var last = 0
        
        for next in remaining {
            let ( nextDistance, end ) = pathDistance( current: next, remaining: remaining )
            
            if nextDistance + distanceMap[current][next] < distance {
                distance = nextDistance + distanceMap[current][next]
                last = end
            }
        }
        
        return ( distance, last )
    }
    
    func findDistances() -> [[Int]] {
        var map = Array( repeating: Array( repeating: 0, count: destinations.count ), count: destinations.count )
        
        for i in 0 ..< destinations.count - 1 {
            for j in i + 1 ..< destinations.count {
                let distance = findRoute( begin: destinations[i], end: destinations[j] )
                
                map[i][j] = distance
                map[j][i] = distance
            }
        }
        
        return map
    }

    func openEndedDistance() -> Int {
        let remaining = Set( 0 ..< destinations.count )
        let ( distance, _ ) = pathDistance( current: 0, remaining: remaining )
        
        return distance
    }
    
    func returnDistance() -> Int {
        let remaining = Set( 1 ..< destinations.count )
        var distance = Int.max
        
        for next in remaining {
            let ( nextDistance, end ) = pathDistance( current: next, remaining: remaining )
            let trialDistance = nextDistance + distanceMap[0][next] + distanceMap[0][end]
            
            if trialDistance < distance { distance = trialDistance }
        }
        
        return distance
    }
}



var ducts = Ducts(input: input)

print( "\(ducts.layout[0].count) x \(ducts.layout.count)" )
//ducts.printLayout()

print( "Part1:", ducts.openEndedDistance() )
print( "Part2:", ducts.returnDistance() )
